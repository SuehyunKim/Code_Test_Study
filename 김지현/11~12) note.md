# 스택

- 데이터를 보관하는 선형 구조
- 한 쪽 끝으로 밀어 넣고(push 연산), 같은 쪽에서 뽑아 꺼내야 함(pop 연산)
  - 후입선출(LIFO, Last-In-First-Out) 방식
- `S = Stack()` - empty stack

→ `S.push(A)`, `.S.push(B)` - 원소 A, B 추가

→ `r1 = S.pop()` - 원소 B 삭제

→ `r2 = S.pop()` - 원소 A 삭제

- 오류

  - Stack underflow: empty stack에서 데이터 삭제 시 - `r3 = S.pop()`
  - Stack overflow: full stack에 데이터 추가 시 - `S.push(C)`

- 라이브러리

```python
from pythonds.basic.stack import Stack
S= Stack()
dir(S)
```

# 스택의 추상적 자료형

### Operations

- `.size()`: 원소의 수
- `.isEmpty()`: 스택이 비어 있는지의 여부
- `.push(x)`: 원소 x 추가
- `.pop()`: 마지막 (맨 위) 원소를 삭제/반환
- `.peek()`: 마지막 (맨 위) 원소를 반환 (삭제 x)

## By 배열

```python
class ArrayStack:
    def __init__(self):
        self.data = []

    def size(self):
        return len(self.data)

    def isEmpty(self):
        return self.size() == 0

    def push(self, item):
        self.data.append(item)

    def pop(self):
        return self.data.pop()

    def peek(self):
        return self.data[-1]
```

## By 이중 연결 리스트

```python
class LinkedListStack:
    def __init__(self):
        self.data = DoublyLinkedList()

    def size(self):
        return self.data.nodeCount

    def isEmpty(self):
        return self.size() == 0

    def push(self, item):
        node = Node(item)
        self.data.insertAt(self.size() + 1, node)

    def pop(self):
        return self.data.popAt(self.size())

    def peek(self):
        return self.data.getAt(self.size()).data
```

- 중위 표기법: 연산자가 피연산자들의 사이에 위치
- 후위 표기법: 연산자가 피연산자들의 뒤에 위치
- 중위 → 후위

```
1. 왼쪽부터 읽음
2. 피연산자는 그대로 출력
3. ( 이면 스택에 push
4. ) 이면 ( 가 나올 때까지 스택에서 pop/출력
5. 연산자이면 그보다 우선순위가 높거나 같은 연산자들을 pop/출력 후 해당 연산자는 push
6. 스택에 마지막으로 남아 있는 연산자들 pop/출력
```

- `A*B + C` → `A B * C +`
- `A + B + C` → `A B + C +`

1. 피연산자 출력
2. 스택이 비어 있다면, 연산자는 스택에 push
3. 스택이 비어있지 않으면, 새로운 연산자 만났을 때 우선순위 비교하여 pop, push
4. 스택에 마지막으로 남아 있는 연산자들 pop

- `A + B*C` → `A B C * +`

1~2 동일

3. 곱셈 후에 덧셈을 해야 하므로 스택에 곱셈 push
4. 남아 있는 연산자들 마지막에 pop

- `(A+B) * C` → `A B + C *`

1. 스택에 여는 괄호 push
2. 닫는 괄호 만나면, 스택에서 여는 괄호 나올 때 까지 pop - 여는 괄호의 낮은 우선순위 활용

- `A * (B+C)` → `A B C + *`

  - B+C가 먼저 계산돼야 함
  - 여는 괄호 너머(`*`)까지 pop되지 않도록 함

- `(A+B) * (C+D)` → `A B + C D + *`
- `(A + (B-C)) * D` → `A B C - + D *`
- `A * (B- (C+D))` → `A B C D + - *`
